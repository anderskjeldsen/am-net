namespace HttpServer {
    class HttpRequest {
        import Am.Lang

        var method: String = ""
        var path: String = ""
        var requestLine: String = ""
        var headers: String = ""
        var body: String = ""
        
        static fun create(method: String, path: String, requestLine: String, headers: String, body: String): HttpRequest {
            var request = new HttpRequest()
            request.method = method
            request.path = path
            request.requestLine = requestLine
            request.headers = headers
            request.body = body
            return request
        }
    }
    
    class SimpleHttpServer(private var port: Int) {
        import Am.Lang
        import Am.IO
        import Am.Net
        import Am.Json
        import Am.Util.Parsers.Text

        private var serverSocket: Socket
        private var isRunning: Bool = false

        fun start() {
            ("Starting HTTP server on port " + this.port.toString()).println()
            
            // Create server socket
            this.serverSocket = Socket.create(AddressFamily.inet, SocketType.stream, ProtocolFamily.unspecified)
            
            // Bind to port
            this.serverSocket.bind(this.port)
            
            // Listen for connections
            this.serverSocket.listen(10)
            
            this.isRunning = true
            ("HTTP server listening on port " + this.port.toString()).println()
            
            // Accept connections in a loop
            this.acceptLoop()
        }

        fun stop() {
            this.isRunning = false
            if (this.serverSocket != null) {
                this.serverSocket.close()
            }
            "HTTP server stopped".println()
        }

        private fun acceptLoop() {
            while (this.isRunning) {
                try {
                    "Waiting for client connection...".println()
                    var clientSocket = this.serverSocket.accept()
                    "Client connected".println()
                    
                    // Handle the client request
                    this.handleClient(clientSocket)
                    
                    // Close client connection
                    clientSocket.close()
                    "Client connection closed".println()
                } catch (e: Exception) {
                    ("Error handling client: " + e.message).println()
                }
            }
        }

        private fun handleClient(clientSocket: Socket) {
            try {
                // Create streams for communication
                var socketStream = new SocketStream(clientSocket)
                var inputStream = socketStream as Stream
                var textStream = new TextStream(inputStream)
                
                // Read the HTTP request
                var httpRequest = this.readHttpRequest(textStream)
                ("Received request: " + httpRequest.requestLine).println()
                
                // If this is a POST request with JSON content, parse the body
                if (httpRequest.method == "POST") {
                    this.parseJsonBody(httpRequest.body)
                }
                
                // Generate and send HTTP response
                var response = this.generateHttpResponse(httpRequest.requestLine)
                this.sendHttpResponse(textStream, response)
                
            } catch (e: Exception) {
                ("Error processing client request: " + e.message).println()
            }
        }

        private fun readHttpRequest(textStream: TextStream): HttpRequest {
            // Read data from the socket
            var buffer: UByte[] = new UByte[4096]
            var bytesRead = textStream.read(buffer, 0L, 4096UI)
            
            var requestText = ""
            if (bytesRead > 0UI) {
                try {
                    requestText = String.fromBytes(buffer, "UTF-8")
                } catch (e: Exception) {
                    requestText = "GET / HTTP/1.1\r\n\r\n"
                }
            }
            
            // Simple parsing - just get the first line for method and path
            var requestLine = "GET / HTTP/1.1"
            var method = "GET"
            var path = "/"
            
            // Find the first line
            var crlfIndex = requestText.indexOf("\r\n")
            if (crlfIndex >= 0) {
                requestLine = requestText.substring(0UI, crlfIndex.toUInt())
                
                // Parse method from first word
                var spaceIndex = requestLine.indexOf(" ")
                if (spaceIndex >= 0) {
                    method = requestLine.substring(0UI, spaceIndex.toUInt())
                    
                    // Parse path from second word
                    var secondSpaceIndex = requestLine.indexOfAfter(" ", (spaceIndex + 1))
                    if (secondSpaceIndex >= 0) {
                        path = requestLine.substring((spaceIndex + 1).toUInt(), secondSpaceIndex.toUInt())
                    }
                }
            }
            
            // Find headers and body separation
            var headerEndIndex = requestText.indexOf("\r\n\r\n")
            var headers = ""
            var body = ""
            
            if (headerEndIndex >= 0) {
                headers = requestText.substring(0UI, headerEndIndex.toUInt())
                var bodyStart = (headerEndIndex + 4)
                if (bodyStart < requestText.length()) {
                    body = requestText.substringToEnd(bodyStart.toUInt())
                }
            } else {
                headers = requestText
            }
            
            return HttpRequest.create(method, path, requestLine, headers, body)
        }

        private fun parseJsonBody(body: String) {
            if (body.length() == 0) {
                "No request body to parse".println()
                return
            }
            
            try {
                "Parsing JSON body:".println()
                body.println()
                
                var textParser = new TextParser(body)
                var parser = new JsonParser(textParser)
                var jsonValue = parser.parse()
                
                "Parsed JSON successfully:".println()
                this.printJsonValue(jsonValue)
                
            } catch (e: Exception) {
                ("Error parsing JSON: " + e.message).println()
                ("Raw body content: " + body).println()
            }
        }
        
        private fun printJsonValue(jsonValue: JsonValue) {
            "JSON Value contents:".println()
            // Print the JSON value type and basic info
            ("JSON type: " + jsonValue.type.toString()).println()
            
            if (jsonValue.type == JsonValueType.objectType) {
                var jsonObject = jsonValue.value as JsonObject
                ("JSON object with " + jsonObject.size().toString() + " properties").println()
            } else if (jsonValue.type == JsonValueType.stringType) {
                ("JSON string value: " + jsonValue.value.toString()).println()
            } else {
                ("JSON value: " + jsonValue.value.toString()).println()
            }
        }

        private fun generateHttpResponse(request: String): String {
            var statusLine = "HTTP/1.1 200 OK\r\n"
            var headers = "Content-Type: text/html\r\n"
            headers = headers + "Connection: close\r\n"
            
            var body = "<html><head><title>AmLang HTTP Server</title></head>"
            body = body + "<body>"
            body = body + "<h1>Welcome to AmLang HTTP Server!</h1>"
            body = body + "<p>Request received: " + request + "</p>"
            body = body + "<p>Server is running successfully on port " + this.port.toString() + "</p>"
            body = body + "</body></html>"
            
            var contentLength = "Content-Length: " + body.length().toString() + "\r\n"
            
            return statusLine + headers + contentLength + "\r\n" + body
        }

        private fun sendHttpResponse(textStream: TextStream, response: String) {
            // Send response as string
            textStream.writeString(response)
        }
    }
}